"""Recommended tool workflows for common agent tasks.

Returns structured guidance so agents can orient themselves at the start
of a session without relying on implicit knowledge of the tool set.
"""

_WORKFLOWS: dict = {
    "design_experiment": {
        "description": (
            "Design a new MITgcm experiment from physical parameters."
        ),
        "steps": [
            {
                "tool": "translate_lab_params_tool",
                "purpose": (
                    "Convert physical lab parameters (tank size, rotation rate, "
                    "temperature contrast) to MITgcm namelist values."
                ),
            },
            {
                "tool": "check_scales_tool",
                "purpose": (
                    "Compute dimensionless numbers (Ek, Ro, Bu) and check CFL / "
                    "Ekman resolution. Resolve flagged warnings before proceeding."
                ),
            },
            {
                "tool": "lookup_gotcha_tool",
                "purpose": (
                    "Search the gotcha catalogue for known traps relevant to your "
                    "setup (e.g. 'nonhydrostatic', 'rigid lid', 'RBCS', 'spin-up')."
                ),
            },
            {
                "tool": "suggest_experiment_config_tool",
                "purpose": (
                    "Get skeleton CPP_OPTIONS.h, namelist stanzas, and a Docker "
                    "build/run recipe for the experiment type."
                ),
            },
            {
                "tool": "search_docs_tool",
                "purpose": (
                    "Find SIZE.h and other headers from verification examples that "
                    "match your grid dimensions."
                ),
            },
            {
                "tool": "get_doc_source_tool",
                "purpose": (
                    "Read the full text of a SIZE.h or doc section returned by "
                    "search_docs_tool."
                ),
            },
        ],
        "notes": [
            "Binary input files (.bin) are not generated by these tools â€” write a Python/numpy script.",
            "The 'quickstart' key in suggest_experiment_config_tool output has the Docker build and run commands.",
        ],
    },
    "debug_configuration": {
        "description": "Diagnose why a configuration does not compile or run correctly.",
        "steps": [
            {
                "tool": "lookup_gotcha_tool",
                "purpose": (
                    "Search by symptom first (e.g. 'CFL instability', "
                    "'DIAGNOSTICS_SIZE', 'rigid lid', 'nonhydrostatic')."
                ),
            },
            {
                "tool": "namelist_to_code_tool",
                "purpose": "Find which subroutine reads a suspect namelist parameter.",
            },
            {
                "tool": "get_source_tool",
                "purpose": "Read the subroutine source to understand what the parameter controls.",
            },
            {
                "tool": "get_cpp_requirements_tool",
                "purpose": "Check which CPP flags must be defined for a subroutine to compile in.",
            },
            {
                "tool": "search_code_tool",
                "purpose": "Semantic search when you don't know the subroutine name.",
            },
        ],
        "notes": [],
    },
    "understand_package": {
        "description": "Learn what a MITgcm package does and how to configure it.",
        "steps": [
            {
                "tool": "search_docs_tool",
                "purpose": "Search documentation for the package name and behaviour.",
            },
            {
                "tool": "get_package_flags_tool",
                "purpose": "List all compile-time CPP flags the package exposes.",
            },
            {
                "tool": "find_subroutines_tool",
                "purpose": "Find key subroutines by name (e.g. PKG_INIT, PKG_READPARMS).",
            },
            {
                "tool": "get_source_tool",
                "purpose": "Read subroutine source for implementation details.",
            },
            {
                "tool": "get_callers_tool",
                "purpose": "Trace where the package is called from in the model loop.",
            },
        ],
        "notes": [],
    },
    "explore_code": {
        "description": "Navigate MITgcm source to answer a specific code question.",
        "steps": [
            {
                "tool": "search_code_tool",
                "purpose": "Semantic search when you don't know the subroutine name.",
            },
            {
                "tool": "find_subroutines_tool",
                "purpose": "Look up a subroutine by exact name.",
            },
            {
                "tool": "get_source_tool",
                "purpose": "Read source, paginated with offset/limit for large routines.",
            },
            {
                "tool": "get_callers_tool",
                "purpose": "Find what calls this subroutine.",
            },
            {
                "tool": "get_callees_tool",
                "purpose": "Find what this subroutine calls.",
            },
            {
                "tool": "diagnostics_fill_to_source_tool",
                "purpose": "Find which subroutine fills a named diagnostics output field.",
            },
        ],
        "notes": [],
    },
}


def get_workflow(task: str | None = None) -> dict:
    """Return recommended tool sequences for common tasks.

    Parameters
    ----------
    task : str or None
        One of "design_experiment", "debug_configuration",
        "understand_package", "explore_code".
        If None, all workflows are returned.

    Returns
    -------
    dict
        Mapping of task name to workflow dict with keys:
        description, steps (list of {tool, purpose}), notes.
        Empty dict if the task name is not recognised.
    """
    if task is not None:
        key = task.lower().strip().replace(" ", "_")
        return {key: _WORKFLOWS[key]} if key in _WORKFLOWS else {}
    return dict(_WORKFLOWS)
