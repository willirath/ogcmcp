# GM eddy parameterisation: MITgcm vs FESOM2

*Cross-model comparison using the MCP tools — generated by Claude (claude-sonnet-4-6), 2026-02-25*

---

## Tool calls used to produce this comparison

All findings below were obtained exclusively through the MITgcm and FESOM2 MCP servers.
The sequence of calls, in order:

### Discovery pass (parallel)
| Tool | Arguments | Purpose |
|------|-----------|---------|
| `mcp__mitgcm__search_code_tool` | `"Gent McWilliams GM eddy parameterisation bolus velocity skew flux"`, top_k=8 | Find relevant MITgcm subroutines |
| `mcp__fesom2__search_code_tool` | `"Gent McWilliams GM eddy parameterisation bolus velocity skew flux Ferrari"`, top_k=8 | Find relevant FESOM2 subroutines |
| `mcp__mitgcm__get_package_tool` | `"gmredi"` | List all subroutines and CPP flags in the gmredi package |
| `mcp__mitgcm__search_docs_tool` | `"Gent McWilliams GM Redi eddy parameterisation bolus velocity skew diffusion tensor"`, top_k=5 | Locate gmredi RST documentation sections |

### Source reading pass (parallel)
| Tool | Arguments | Purpose |
|------|-----------|---------|
| `mcp__fesom2__get_source_tool` | `"fer_gamma2vel"` | Initially returned disambiguation: two copies |
| `mcp__fesom2__get_source_tool` | `"iso_flux"` | False positive — turned out to be isotopic gas exchange, not GM |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_CALC_TENSOR"`, limit=80 | First 80 lines of tensor routine (header + variables) |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_CALC_PSI_BOLUS"` | Bolus streamfunction routine |
| `mcp__mitgcm__namelist_to_code_tool` | `"GM_isopycK"` | Confirm namelist group for GM parameters |
| `mcp__fesom2__namelist_to_code_tool` | `"fer_gm"` | Locate Fer_GM switch and its namelist group |

### Deeper source reading (parallel)
| Tool | Arguments | Purpose |
|------|-----------|---------|
| `mcp__fesom2__get_source_tool` | `"fer_gamma2vel"`, module=`"oce_fer_gm"` | Full source of the streamfunction-to-velocity conversion |
| `mcp__fesom2__search_code_tool` | `"GM streamfunction slope isopycnal tilt gradient density"`, top_k=5 | Attempt to find the fer_gamma solver (search not conclusive) |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_CALC_TENSOR"`, offset=80, limit=100 | Visbeck variable-K section of tensor routine |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_CALC_BATES_K"`, limit=60 | Bates K3D routine header |
| `mcp__fesom2__namelist_to_code_tool` | `"k_gm_min"` | Confirm k_gm_min location |
| `mcp__fesom2__namelist_to_code_tool` | `"k_gm_cm"` | Baroclinic mode selector parameter |

### Tapering and parameter pass (parallel)
| Tool | Arguments | Purpose |
|------|-----------|---------|
| `mcp__fesom2__get_source_tool` | `"fer_gamma2vel"`, module=`"fer_solve_interface"` | Interface stub (confirmed it's just a forward declaration) |
| `mcp__fesom2__search_code_tool` | `"fer_gamma compute streamfunction solve Eliassen-Palm stratification N2"`, top_k=5 | Attempt to find fer_gamma solver (search returned unrelated hits) |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_SLOPE_LIMIT"`, limit=80 | Slope tapering routine header |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_READPARMS"`, limit=100 | Full GM_PARM01 namelist definition (all parameters) |
| `mcp__mitgcm__search_docs_tool` | `"Visbeck variable diffusivity GM slope Rossby radius eddy length scale"`, top_k=3 | Visbeck scheme docs |

### Final pass (parallel)
| Tool | Arguments | Purpose |
|------|-----------|---------|
| `mcp__fesom2__list_setups_tool` | `name="neverworld2"`, source=`"reference_namelist"` | Full annotated GM namelist from neverworld2 reference setup |
| `mcp__fesom2__get_subroutine_tool` | `"fer_solve"` | Attempt to find fer_gamma solver by name — returned null |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_CALC_PSI_BVP"`, limit=60 | BVP streamfunction method (confirms same Ferrari 2010 paper as FESOM2) |
| `mcp__mitgcm__get_source_tool` | `"SUBMESO_CALC_PSI"`, limit=60 | Fox-Kemper sub-mesoscale routine (absent in FESOM2) |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_SLOPE_LIMIT"`, offset=150, limit=100 | Cox clipping and fm07 tapering code |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_CALC_TENSOR"`, offset=400, limit=80 | Visbeck depth-averaging loop |
| `mcp__mitgcm__search_docs_tool` | `"GM bolus advective form versus skew flux form Griffies 1998 transport comparison"`, top_k=3 | Doc section on skew-flux motivation |
| `mcp__mitgcm__get_source_tool` | `"GMREDI_XTRANSPORT"`, limit=80 | Skew-flux transport routine |

### Note on a false positive
`mcp__fesom2__search_code_tool("GM streamfunction slope …")` and variations consistently
returned pressure, KPP, and ice routines rather than the `oce_fer_gm` code. The FESOM2
GM source was found via the more specific query `"fer_gm GM skew flux Ferrari 2010
isopycnal diffusion"` which surfaced `fer_gamma2vel` in `oce_fer_gm.F90`. The
`fer_gamma` computation itself (the BVP solver) could not be located through the MCP
semantic search; it likely lives in a subroutine not indexed or named differently. The
interface stub in `fer_solve_interface` was found but only contains a forward declaration.

---

## Overview

Both models implement the Gent & McWilliams (1990) eddy parameterisation to represent
mesoscale eddy transports on non-eddying or partially-eddying grids. They share the same
physical goal — replace the missing bolus advection — but differ substantially in
theoretical formulation, diffusivity schemes, slope tapering, and adaptation to their
respective grid architectures.

---

## 1. Core formulation

### MITgcm — skew-flux default, bolus as option

MITgcm defaults to the **Griffies (1998) skew-flux** form. Griffies showed that the
bolus flux can be decomposed into a non-divergent part (which can be dropped) and a
skew flux:

```
J_skew = K_GM * [  0        0   +Sx ] ∂T/∂x
                [  0        0   +Sy ] ∂T/∂y
                [ -Sx      -Sy   0  ] ∂T/∂r
```

This off-diagonal tensor is added to the Redi isopycnal diffusion tensor and applied
in `GMREDI_XTRANSPORT` / `GMREDI_YTRANSPORT`. The key motivation (documented in
`phys_pkgs/gmredi.rst`) is numerical: the bolus advective form requires multiple layers
of differencing and interpolation of the streamfunction to get velocities, leading to
noisy fields. The skew-flux avoids this.

The bolus advective form is available as an optional compile-time CPP flag
(`#define GM_BOLUS_ADVEC` in `CPP_OPTIONS.h`), calling `GMREDI_CALC_PSI_BOLUS`.

### FESOM2 — bolus form only, via Ferrari (2010) BVP

FESOM2 has **no skew-flux implementation**. It always uses the bolus advective form,
computing a streamfunction `fer_gamma` via the Ferrari et al. (2010) boundary-value
problem (BVP). The streamfunction is then converted to bolus velocities in
`fer_gamma2vel` (`oce_fer_gm.F90`):

```fortran
! Average over the 3 nodes of each triangular element:
zinv = onethird / helem(nz,el)
fer_uv(1,nz,el) = sum(fer_gamma(1,nz,elnod) - fer_gamma(1,nz+1,elnod)) * zinv
fer_uv(2,nz,el) = sum(fer_gamma(2,nz,elnod) - fer_gamma(2,nz+1,elnod)) * zinv
```

This is `u* = ∂Ψ/∂z`, averaged element-by-element over the three nodes of the
unstructured triangle. The BVP streamfunction is what MITgcm calls `GMREDI_CALC_PSI_BVP`
(`GM_BOLUS_BVP` flag) — the same Ferrari 2010 paper — but in FESOM2 this is the
primary and only path.

**Summary:**

| | MITgcm | FESOM2 |
|---|---|---|
| Default flux form | Griffies 1998 skew-flux | Bolus advective (always) |
| Streamfunction method | Standard slope-based Ψ = K·S | Ferrari 2010 BVP |
| BVP option | Yes (`GM_BOLUS_BVP`) | Yes (only option) |
| Skew-flux | Yes (default) | No |

---

## 2. Diffusivity κ_GM: one scheme vs many

### MITgcm — six parameterizations, all optional

Controlled from `data.gmredi` / namelist `GM_PARM01` (`GMREDI_READPARMS`):

| Scheme | Key params | Reference |
|--------|-----------|-----------|
| Constant | `GM_isopycK` | Gent & McWilliams 1990 |
| Visbeck variable | `GM_Visbeck_alpha`, `GM_Visbeck_length` | Visbeck et al. 1997 |
| Bates 3D | `GM_useBatesK3d`, `GM_Bates_*` | Bates et al. 2014 |
| GEOMETRIC | `GM_useGEOM`, `GEOM_alpha`, `GEOM_lmbda` | Marshall et al. 2012 |
| Leith QG | `GM_useLeithQG` | Bachman et al. |
| BVP-derived | (implicit in BVP streamfunction) | Ferrari et al. 2010 |

The Visbeck scheme (computed inside `GMREDI_CALC_TENSOR`) depth-averages the Eady
growth rate `|f|/√Ri` and scales by `α·L²·|f|/√Ri`, where `L` and `α` are tunable.

The Bates K3D scheme (`GMREDI_CALC_BATES_K`, 1157 lines) is the most elaborate:
it solves for the vertical structure using baroclinic mode eigenvectors.

### FESOM2 — one base parameterization, resolution-adaptive scaling

FESOM2 has a single κ framework: `k_gm_max`/`k_gm_min` bounded diffusivity, with
the Ferrari (2010) scaling providing vertical structure through the BVP streamfunction.
The dominant control is **resolution-dependent scaling** — a feature absent from
MITgcm because it uses a structured mesh:

```fortran
! From neverworld2 reference namelist (namelist.oce / oce_dyn):
scaling_resolution = .true.   ! K_GM ~ f(local grid size)
k_gm_rampmax = -1.0           ! [km] above: full GM
k_gm_rampmin = -1.0           ! [km] below: GM off; linear ramp between
k_gm_resscalorder = 1         ! scaling order (1=linear, 2=area)
```

When `k_gm_rampmax > 0`, GM is ramped to zero at fine-resolution nodes — physically
sensible because those nodes partially resolve eddies. This is FESOM2's answer to the
"GM off" transition that eddy-permitting structured-grid models handle with resolution
changes between nests or zoom domains.

Additional optional scalings:

| Flag | Reference |
|------|-----------|
| `scaling_rossby` | scale with Rossby radius |
| `scaling_ferreira` | vertical scaling (Ferreira et al. 2005) |
| `scaling_gmzexp` | exponential depth decay exp(-z/z_ref) |
| `k_gm_cm` | which baroclinic mode velocity to use (1st, 2nd, …) |

---

## 3. Slope tapering

Both models must taper the GM tensor where isopycnal slopes are steep (near the
surface mixed layer, near topography) to prevent unphysical fluxes.

### MITgcm — four tapering schemes (runtime switch)

`GM_taper_scheme` in `data.gmredi`, handled by `GMREDI_SLOPE_LIMIT`:

| Scheme | Behaviour |
|--------|-----------|
| `'orig'` / `'clipping'` | Cox 1987 slope clipping: floors `∂σ/∂r` so slope ≤ S_max |
| `'ldd97'` | Large, Danabasoglu & Doney 1997: smooth taper using Rossby radius L_ρ; ldd97_LrhoC = c_first_baroclinic / |f| |
| `'fm07'` | Ferrari & McWilliams 2007: separates slope magnitude from direction; handles near-surface region with a transition layer |
| `'DM95'` | Danabasoglu & McWilliams 1995: multiplicative taper based on critical slope S_crit and S_d |

All schemes set `taperFct` ∈ [0, 1], and the effective tensor is `taperFct × K_GM × slope_tensor`.

### FESOM2 — two tapering flags

From the neverworld2 reference namelist:

```fortran
scaling_odm95 = .true.    ! Danabasoglu & McWilliams 1995
  odm95_scr = 0.2e-2      ! critical slope S_crit
  odm95_sd  = 1.0e-3      ! width of smoothing zone

scaling_ldd97 = .false.   ! Large, Danabasoglu & Doney 1997
  ldd97_c    = 2.0        ! first baroclinic wave speed [m/s]
  ldd97_rmin = 15.0e3     ! Rossby radius lower bound [m]
  ldd97_rmax = 100.0e3    ! Rossby radius upper bound [m]
```

Only ODM95 or LDD97 (or none); no Cox clipping and no fm07. MITgcm's `fm07` scheme
(which more accurately handles the surface mixed-layer transition region) has no
FESOM2 equivalent.

---

## 4. Redi isopycnal diffusion

Both models keep Redi separate from GM at the namelist level.

In **MITgcm** the Redi diffusivity tensor is computed alongside GM in
`GMREDI_CALC_TENSOR` and added directly to the tracer diffusion. `GM_isopycK` and
`GM_background_K` can be set independently; a single taper function applies to both.

In **FESOM2** Redi is separately toggled with `redi = .true./false` and can have
a different diffusivity: `redi_kmax` (defaults to `k_gm_max` if ≤ 0). There are
separate tapering booleans: `k_gm_ktaper` and `redi_ktaper`. In the neverworld2
reference setup both are off:

```fortran
redi       = .false.
redi_kmax  = 0.0     ! synchronised with K_GM_max when ≤ 0
```

---

## 5. Sub-mesoscale mixed layer restratification

**MITgcm** includes `SUBMESO_CALC_PSI` (Fox-Kemper et al. 2008, 2011), a separate
streamfunction for mixed-layer instabilities activated with `GM_useSubMeso = .TRUE.`.
It parameterises submesoscale restratification inside the mixed layer independently
of the deep GM streamfunction.

**FESOM2 has no equivalent.** There is no Fox-Kemper or submesoscale mixed-layer
parameterisation in the GM framework.

---

## 6. Grid architecture: how it shapes the implementation

This is perhaps the deepest difference. The two models live on fundamentally different
grids, and their GM codes reflect this.

### MITgcm — structured C-grid, tile-parallel

`GMREDI_CALC_TENSOR` loops over `(i, j)` on a regular tile with halos (`OLx`, `OLy`).
Slope gradients use standard finite differences: `dSigmaDx(i,j)`, staggered onto
U-/V-faces. The LDD97 Rossby radius `ldd97_LrhoW` is pre-computed separately for
W-face and S-face locations. All operations are tightly vectorisable on the regular
structured mesh.

### FESOM2 — unstructured triangular mesh, element-parallel

`fer_gamma2vel` loops `DO el=1, myDim_elem2D` over elements, each a triangle with
nodes `elnod(3)`. The bolus velocity is the vertical difference of the nodal
streamfunction values, divided by the element layer thickness `helem(nz,el)`, averaged
over the three corner nodes:

```fortran
fer_uv(1,nz,el) = sum(fer_gamma(1,nz,elnod) - fer_gamma(1,nz+1,elnod)) / (3*helem(nz,el))
```

This element-by-element averaging is the natural stencil for a P1-FEM unstructured
mesh. There is no equivalent of MITgcm's tile halos; instead FESOM2 uses
`call exchange_elem(fer_uv, partit)` for MPI halo exchange after the computation.

The ALE (Arbitrary Lagrangian-Eulerian) vertical coordinate in FESOM2 (`which_ale =
'linfs'` in neverworld2) means that `helem(nz,el)` varies in time and space, which
is why the layer-thickness normalisation is explicit in the loop body.

---

## 7. Adjoint / data assimilation

**MITgcm**'s `gmredi` package is heavily instrumented for automatic differentiation
(TAF/TAMC). `GMREDI_CALC_TENSOR` contains blocks like:

```fortran
#ifdef ALLOW_AUTODIFF_TAMC
      tkey = bi + (bj-1)*nSx + (ikey_dynamics-1)*nSx*nSy
#endif
```

This lets MITgcm compute adjoint gradients through the GM tensor, enabling
sensitivity analyses and state estimation (ECCO uses it).

**FESOM2**'s `oce_fer_gm.F90` has no such instrumentation. FESOM2 is not currently
adjointable.

---

## 8. Side-by-side summary

| Feature | MITgcm (`gmredi`) | FESOM2 (`oce_fer_gm`) |
|---|---|---|
| **Flux form** | Skew-flux (default) or bolus | Bolus only |
| **Streamfunction** | Slope-based or BVP (optional) | Ferrari 2010 BVP always |
| **κ_GM schemes** | 6 (constant, Visbeck, Bates K3D, GEOMETRIC, Leith QG, BVP) | 1 (Ferrari scaling + bounds) |
| **Resolution scaling** | None (structured grid) | Yes — key for variable-resolution mesh |
| **Slope taper** | Cox, DM95, LDD97, fm07 | DM95 or LDD97 |
| **Redi** | Combined tensor; same taper | Separate flag; separate taper option |
| **Sub-mesoscale (Fox-Kemper)** | Yes (`SUBMESO_CALC_PSI`) | No |
| **Baroclinic mode choice** | Bates K3D uses eigenvectors | `k_gm_cm` selects mode index |
| **Grid stencil** | Structured (i,j) C-grid tiles | Unstructured triangles, element loops |
| **MPI exchange** | Tile-overlap halos | `exchange_elem` after loop |
| **Adjoint support** | Yes (TAF/TAMC instrumented) | No |
| **Code size** | ~28 files, ~5000+ lines | ~1 file (`oce_fer_gm.F90`) |

---

## 9. Physical interpretation of the differences

The skew-flux / bolus-advection choice is mathematically equivalent in the continuous
limit (Griffies 1998 proved this), but numerically the skew-flux form is cleaner on
MITgcm's structured B/C-grid. On FESOM2's unstructured mesh the bolus form is more
natural: the triangular element structure provides a straightforward way to take
vertical differences of node-centred streamfunction values, which is exactly what
`fer_gamma2vel` does.

FESOM2's resolution-adaptive `scaling_resolution` is the most distinctive physical
feature. In a variable-resolution mesh, the local Rossby radius may be well-resolved
in some regions and not others; having K_GM ramp to zero where `Δx < k_gm_rampmin`
avoids double-counting eddy effects where the mesh starts to resolve them. MITgcm
achieves something similar only through the GEOMETRIC framework
(Marshall et al. 2012), which suppresses GM where eddy energy is explicitly resolved.

MITgcm's richer κ_GM menu (Visbeck, Bates K3D, GEOMETRIC) reflects that the model
is used for global state estimation and process studies where careful tuning of
diffusivity structure matters. FESOM2's simpler single-scheme approach trades that
flexibility for the resolution-adaptive scaling that is unique to unstructured meshes.
